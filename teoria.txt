==================== CONDICIONAIS ============================

O que é uma condicional?

Sintaxe da condicional IF

if (expressao) {

    vá por esse caminho

} else {

    vá por outro caminho 
};

Exemplo

Qualquer condicional é avaliada em termos de true ou false
/ 
if 
else if
else

const idade = 189;

if (idade >= 18) {
    console.log('pode dirigir'); 
} else if ( idade >=17) {
    console.log('pode procurar a auto escola');
} else {
    console.log ('abaixo da idade mínima');
    };

=========================== OPERADORES ===============================

OPERADORES DE COMPARAÇÃO
OPERADORES LÓGICOS - TABELA DA VERDADE
&& (AND) 
|| (OU)
! (NOT - operador de negação)

O JavaScript avalia qualquer valor como verdadeiro (truthy) ou falso (falsy), 
mesmo que não sejam do tipo booleano.

Por exemplo, se a variável possuiCNH tiver o valor 'true' (uma string, e 
não o booleano true), ainda assim ela será avaliada como verdadeira em uma 
condição if. Isso porque qualquer string não vazia é um valor truthy.


=========================== TERNÁRIO ===============================

const saudacao = nome ? `olá, ${nome}` : 'olá, pessoa';
console.log(saudacao); // olá, Fernando

A condição;
O caso verdadeiro;
O caso falso.

const nome = "Fernando";
let saudacao;

if (nome) {
    saudacao = `olá, ${nome}`;
} else {
    saudacao = 'olá, pessoa';
}

=========================== SWITCH-CASE ===============================

 A diferença entre o switch-case e o if-else é que, no if-else, 
 temos condições intermediárias, conhecidas como else ifs.

Cada else if requer uma condição específica. Quando elencamos muitos else ifs, 
o código pode se tornar difícil de entender. O switch-case, por outro lado, 
é útil quando temos uma lista de possibilidades para o condicional, além de if e else.

Outra diferença é que, enquanto o if-else avalia uma expressão que retorna true ou 
false, o switch trabalha com valores.

switch (avaliacao) {
    case 5:
        console.log('avaliação ótima');
        break;
    case 4:
        console.log('avaliação boa');
        break;
    case 3:
        console.log('avaliação neutra');
        break;
    default:
        console.log('avaliação baixa');
        break;
}

==================== LAÇOS DE REPETIÇÃO ============================

Sintaxe
incialização: executada uma única vez antes do laço começar;
condição: avaliada antes de cada iteração. Se for true, o laço continua; 
Se for false, o laço para.
atualização: executada após cada iteração do laço.
*Nenhuma delas é obrigatória.

As variáveis dentro do for, são recriadas a cada laço.

for (inicialização ; condição; atualização) {



}

Exemplo: 

const numero = 5;

for (let i = 1; i <= 10; i++) {
    const resultado = numero * i;
    console.log(`${numero} x ${i} = ${resultado}`);
}


PROBLEMA: LOOP INFINITO.
*Empilhando instruções até o momento em que a memória não consegue mais executar.
Após iniciar o laço, o programa só continua executando o restante do código 
quando finalizar as iterações do laço.

const numero = 5;

for (let i = 1; i <= 10; ) {
    const resultado = numero * i;
    console.log(`${numero} x ${i} = ${resultado}\n`);
}

Formas de resolução: 
break (pode interromper o laço)

for (let contador = 1; contador <= 50; contador++) {
    const numero = Math.floor(Math.random() * (50 - 1 + 1) + 1);
    if (numero === 15) {
        console.log(`${numero} em ${contador} tentativas`);
        break;
    }
}

continue (interrompe a próxima iteração)

let contador = 0;

for (let i = 1; i <= 20; i++) {
    const numero = Math.floor(Math.random() * (50 - 1 + 1) + 1);
    if (numero % 5 === 0) {
        continue;
    }
    contador++;
}
console.log('contador', contador);


==================== WHILE ============================

Deve ser uma expressão que retorne valores booleanos, podendo ser true ou false.

A condição no while significa que, enquanto for verdadeira, 
o bloco de código será executado. No entanto, ao contrário do for, 
que possui ferramentas internas para manejar a quantidade de repetições, 
o while não possui essa funcionalidade.

Podemos resumir dizendo que o for é utilizado quando queremos especificar 
a quantidade de repetições, enquanto o while executa enquanto a condição 
for verdadeira, sem especificar a quantidade de iterações. 
Se quisermos definir uma condição de parada, devemos fazê-lo fora do laço. 
Por exemplo, podemos criar um contador igual a zero.

while (condição) {
    // bloco de código
}

EXEMPLO

let numeroSecreto = 8;
let numeroAleatorio = 0;
let contador = 0;

while (numeroSecreto !== numeroAleatorio) {
    numeroAleatorio = Math.floor(Math.random() * (50 - 1 + 1) + 1);
    contador++;
}

console.log(`adivinhou em ${contador} tentativas`);

==================== DO WHILE ============================

O do while funciona de maneira semelhante ao while, 
mas com uma diferença importante: enquanto o while, assim como o for, 
pode não entrar na primeira iteração caso a condição já seja falsa, 
o do while garante que, pelo menos uma vez, o bloco de código será executado.

do {
    // bloco de código
} while (condição);

EXEMPLO

let numeroRandom;

do {
    numeroRandom = Math.floor(Math.random() * (50 - 1 + 1) + 1);
} while (numeroRandom % 2 !== 0);

console.log(numeroRandom);

==================== .LENGTH ============================

A propriedade .length está presente em todos os arrays e strings. 
Ela é útil porque nos permite verificar, por exemplo, 
o tamanho de um array ou, no caso de uma string, a quantidade de 
caracteres que ela possui.

sempre podemos saber o tamanho de um array ou de uma parada.

const palavra = "papagaio"; 

for (i=0; i < palavra.length; i++) { 
    console.log(palavra[i]); 
}; 

